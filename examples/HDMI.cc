#include <cxx20/cxxabi.h>
#include <rp2350/clocks.h>
#include <rp2350/common.h>
#include <rp2350/gpio.h>
#include <rp2350/insns.h>
#include <rp2350/interrupts.h>
#include <rp2350/m33.h>
#include <rp2350/pads.h>
#include <rp2350/panic.h>
#include <rp2350/resets.h>
#include <rp2350/ticks.h>
#include <rp2350/uart.h>
#include <rp2350/xoscpll.h>

// For 640x480 at appx. 60fps
static_assert(rp2350::sys::kSysHz == 125'000'000);
constexpr static unsigned kHActive     = 640;
constexpr static unsigned kVActive     = 480;
constexpr static unsigned kHBlankFront = 16;
constexpr static unsigned kHBlankSync  = 96;
constexpr static unsigned kHBlankBack  = 48;
constexpr static unsigned kHBlank      = kHBlankFront + kHBlankSync + kHBlankBack;
constexpr static unsigned kVBlankFront = 10;
constexpr static unsigned kVBlankSync  = 2;
constexpr static unsigned kVBlankBack  = 33;
constexpr static unsigned kVBlank      = kVBlankFront + kVBlankSync + kVBlankBack;
constexpr static unsigned kHTotal      = kHActive + kHBlank;
constexpr static unsigned kVTotal      = kVActive + kVBlank;

namespace rp2350::sys {

// Need to define a couple of structures in our main file so that they are baked into
// the ELF. These two are given `section` attributes so that they can be placed at
// specific flash addresses (see `layout.ld`).

// Interrupt vectors are needed for the thing to start; this will live at flash address
// `0x10000000`. It can live in a different address but the default is fine.
[[gnu::used]] [[gnu::retain]] [[gnu::section(
    ".vec_table")]] ARMVectors const gARMVectors;

// Image definition is required for the RP2 bootloader; this will live at flash address
// `0x10000100`.
[[gnu::used]] [[gnu::retain]] [[gnu::section(
    ".image_def")]] constinit ImageDef2350ARM const gImageDef;

} // namespace rp2350::sys

struct [[gnu::packed]] TMDS {
    unsigned ch0 : 10 {};
    unsigned ch1 : 10 {};
    unsigned ch2 : 10 {};
    unsigned     : 2;

    operator uint32_t() const { return *(uint32_t*)(this); }
};
static_assert(sizeof(TMDS) == 4);

struct TERC {
    unsigned code : 10;
    constexpr operator unsigned() const { return unsigned(code); };
};

// For encoding 4 data bits
constexpr static TERC kTERC[16] {
    {.code = 0b1010011100}, {.code = 0b1001100011}, {.code = 0b1011100100},
    {.code = 0b1011100010}, {.code = 0b0101110001}, {.code = 0b0100011110},
    {.code = 0b0110001110}, {.code = 0b0100111100}, {.code = 0b1011001100},
    {.code = 0b0100111001}, {.code = 0b0110011100}, {.code = 0b1011000110},
    {.code = 0b1010001110}, {.code = 0b1001110001}, {.code = 0b0101100011},
    {.code = 0b1011000011},
};

// Used in preambles and data guards
constexpr static TERC kTERC8 = kTERC[8];
constexpr static TERC kTERC8n {kTERC8.code};

// For encoding 2 control bits:
// CH0: D0=HSYNC  D1=VSYNC
// CH1: D0=CTL0   D1=CTL1
// CH2: D0=CTL2   D1=CTL3
constexpr static TERC kControl[4] {
    {.code = 0b1101010100},
    {.code = 0b0010101011},
    {.code = 0b0101010100},
    {.code = 0b1010101011},
};

// Codes for the 32 levels of RGB color channels.
// TODO: use HSTX's expander or the standalone TMDS converter.
// For now use a fixed table with reasonable patterns (almost-balanced ones and zeros).
// Generated by `misc/tablegen.py`.
// Uses "Limited range" of 16..235 (see "6.6 Video Quantization Ranges")
constexpr static TERC kColors[32] {
    {.code = 0b0111110000}, /*  16 (5 ones) */
    {.code = 0b0111110010}, /*  23 (6 ones) */
    {.code = 0b0111100000}, /*  30 (4 ones) */
    {.code = 0b0111100010}, /*  37 (5 ones) */
    {.code = 0b0111100100}, /*  44 (5 ones) */
    {.code = 0b0111101100}, /*  51 (6 ones) */
    {.code = 0b0111101000}, /*  58 (5 ones) */
    {.code = 0b0100111110}, /*  65 (6 ones) */
    {.code = 0b0111000110}, /*  72 (5 ones) */
    {.code = 0b0100111010}, /*  79 (5 ones) */
    {.code = 0b0100110011}, /*  86 (5 ones) */
    {.code = 0b0111001010}, /*  93 (5 ones) */
    {.code = 0b0111011100}, /* 100 (6 ones) */
    {.code = 0b0111011010}, /* 107 (6 ones) */
    {.code = 0b0111010001}, /* 114 (5 ones) */
    {.code = 0b0111010100}, /* 121 (5 ones) */
    {.code = 0b0111010101}, /* 129 (6 ones) */
    {.code = 0b0101111000}, /* 136 (5 ones) */
    {.code = 0b0101110000}, /* 143 (4 ones) */
    {.code = 0b0101110010}, /* 150 (5 ones) */
    {.code = 0b0110001011}, /* 157 (5 ones) */
    {.code = 0b0110011100}, /* 164 (5 ones) */
    {.code = 0b0110011001}, /* 171 (5 ones) */
    {.code = 0b0101101100}, /* 178 (5 ones) */
    {.code = 0b0110010110}, /* 185 (5 ones) */
    {.code = 0b0110010101}, /* 192 (5 ones) */
    {.code = 0b0110111000}, /* 199 (5 ones) */
    {.code = 0b0110110000}, /* 206 (4 ones) */
    {.code = 0b0110110010}, /* 213 (5 ones) */
    {.code = 0b0101001011}, /* 220 (5 ones) */
    {.code = 0b0101011100}, /* 227 (5 ones) */
    {.code = 0b0101011001}, /* 234 (5 ones) */
};

[[gnu::pure]]
constexpr TMDS color(uint8_t r, uint8_t g, uint8_t b) {
    return {.ch0 = kColors[r], .ch1 = kColors[g], .ch2 = kColors[b]};
}

// Encode 6 bits (2 bits across 3 channels)
[[gnu::pure]]
constexpr TMDS control(uint8_t ch2, uint8_t ch1, uint8_t ch0) {
    return {
        .ch0 = kControl[ch0 & 0x03].code,
        .ch1 = kControl[ch1 & 0x03].code,
        .ch2 = kControl[ch2 & 0x03].code,
    };
}

// Encode 6 bits (2 bits across 3 channels): CTL3..0, plus set CH0 ctl bits for sync
[[gnu::pure]]
constexpr TMDS control(uint8_t ch2, uint8_t ch1, bool vsync, bool hsync) {
    uint8_t v = vsync ? 0b10 : 0b00;
    uint8_t h = hsync ? 0b01 : 0b00;
    return control(ch2, ch1, v | h);
}

[[gnu::pure]]
constexpr TMDS idle() {
    return control(0x00, 0x00, 0x00);
}

[[gnu::pure]]
constexpr TMDS sync(bool vsync, bool hsync) {
    return control(0x00, 0x00, vsync, hsync);
}

[[gnu::pure]]
constexpr TMDS hsync() {
    return control(0x00, 0x00, false, true);
}

[[gnu::pure]]
constexpr TMDS dataPreamble(bool hsync = false, bool vsync = false) {
    // Table 5-2; watch out for the CTL bit order.  CTL3:0 = 0101
    return control(0b01, 0b01, vsync, hsync);
}

[[gnu::pure]]
constexpr TMDS videoPreamble(bool hsync = false, bool vsync = false) {
    // Table 5-2; watch out for the CTL bit order.  CTL3:0 = 0001
    return control(0b00, 0b01, vsync, hsync);
}

[[gnu::pure]]
constexpr TMDS dataGuard(bool hsync = false, bool vsync = false) {
    auto v = vsync ? 0b0010 : 0;
    auto h = hsync ? 0b0001 : 0;
    return {.ch0 = kTERC[0b1100 | v | h].code, .ch1 = kTERC8n, .ch2 = kTERC8n};
}

[[gnu::pure]]
constexpr TMDS videoGuard() {
    return {.ch0 = kTERC8, .ch1 = kTERC8n, .ch2 = kTERC8};
}

struct Buffer {
    unsigned cmd {};
    TMDS hblank[kHBlank];
    TMDS pixels[kHActive]; // TODO: use TMDS commands to generate colors

    void init() {
        unsigned i  = 0;
        unsigned to = 0;
        // We'll start the line in a control period
        to += kHBlankFront;
        while (i < to) { hblank[i++] = idle(); }
        to += kHBlankSync;
        while (i < to) { hblank[i++] = hsync(); }
        to += kHBlankBack;
        while (i < to) { hblank[i++] = idle(); }

        // while (i < 54) { hblank[i++] = dataPreamble(true); } // start preamble (hsync
        // continues) while (i < 56) { hblank[i++] = dataGuard(true); }    // data guard
        // band (hsync continues)
        // // Data period starts after the data guard band.
        // while (i < 88) { hblank[i++] = sync(false, false); }  // nop, placeholder for
        // audio sample while (i < 120) { hblank[i++] = sync(false, false); } // nop,
        // placeholder for audio sample while (i < 122) { hblank[i++] = dataGuard(); }
        // // data guard also ends data period
        // // Back to a control period
        // while (i < 142) { hblank[i++] = idle(); }
        // while (i < 154) { hblank[i++] = videoPreamble(); }
        // while (i < 156) { hblank[i++] = videoGuard(); }
        // // End of the hblank line "header"; after this we send pixels from
        // `buf.pixels`
    }
};
static_assert(sizeof(Buffer) <= 4096);

// We'll claim SRAM8 and SRAM9 for two separately-bussed buffers (see Section 2.2.3
// "SRAM"). We purposely avoid accessing (for read or write) the region of memory
// currently being used by DMA so as to avoid stalls or jitter.
auto& bufA = *(Buffer*)(0x20080000); // Even lines
auto& bufB = *(Buffer*)(0x20081000); // Odd lines

unsigned currentLine  = 0;
unsigned currentFrame = 0;

// Return a reference to a TMDS buffer (one of `bufA` or `bufB`) depending on line
// number
constexpr auto& lineBuffer(unsigned oline) { return (oline & 1) ? bufB : bufA; }

// Generate an empty (no-pixel, no-data) line for the vsync period.
// Line will contain hsync pulse (and vsync throughout, if requested).
void prepVBlankLine(Buffer& buf, bool vsync) {
    unsigned i = 0;
    while (i < 24) { buf.hblank[i++] = sync(vsync, false); }
    while (i < 46) { buf.hblank[i++] = sync(vsync, true); } // hsync
    while (i < 152) { buf.hblank[i++] = sync(vsync, false); }
    i = 0;
    while (i < 848) { buf.pixels[i++] = sync(vsync, false); }
}

// Write pixels into `buf.pixels`.  `displayLine` is in range 0 to 479.
void prepVideoLine(Buffer& buf, unsigned displayLine) {
    (void)displayLine;

    unsigned i  = 0;
    unsigned to = 0;
    // We'll start the line in a control period
    to += kHBlankFront;
    while (i < to) { buf.hblank[i++] = idle(); }
    to += kHBlankSync;
    while (i < to) { buf.hblank[i++] = hsync(); }
    to += kHBlankBack;
    while (i < to) { buf.hblank[i++] = idle(); }

    for (unsigned x = 0; x < 848; x++) {
        uint8_t r     = 20; // (displayLine >> 16) & 0x1f;
        uint8_t g     = 5;  // displayLine & 0x1f;
        uint8_t b     = 22; //(currentFrame >> 3) & 0x1f;
        buf.pixels[x] = color(r, g, b);
    }
}

void prepLine() {
    auto& buf = lineBuffer(currentLine);
    if (currentLine < kVBlankFront) {
        prepVBlankLine(buf, false);
    } else if (currentLine < kVBlankFront + kVBlankSync) {
        prepVBlankLine(buf, true);
    } else if (currentLine < kVBlankFront + kVBlankSync + kVBlankBack) {
        prepVBlankLine(buf, false);
    } else {
        prepVideoLine(buf, currentLine - 20);
    }
}

namespace rp2350::sys {

void initCPUBasic() {
    m33.ccr().unalignedTrap = true;
    m33.ccr().div0Trap      = true;
}

void initSystemClock() {
    xosc.init();
    sysPLL.init();

    clocks.sys.control = {.source    = Clocks::Sys::Source::CLK_SYS_AUX,
                          .auxSource = Clocks::Sys::AuxSource::PLL_SYS};
    clocks.sys.div     = {.fraction = 0, .integer = 1};
}

void initRefClock() {
    clocks.ref.control = {.source = Clocks::Ref::Source::XOSC, .auxSource = {}};
    clocks.ref.div     = {.fraction = 0, .integer = 1};
}

void initPeriphClock() {
    clocks.peri.control = {
        .auxSource = Clocks::Peri::AuxSource::PLL_SYS, .kill = false, .enable = true};
    clocks.peri.div = {.fraction = 0, .integer = 1};
}

void initHSTXClock() {
    update(&clocks.hstx.control, [](auto& _) {
        _.zero();
        _->auxSource = Clocks::HSTX::AuxSource::CLK_SYS;
        _->kill      = false;
        _->enable    = true;
    });
    clocks.hstx.div = {.fraction = 0, .integer = 1};
}

void initSystemTicks() {
    // p569: SDK expects nominal 1uS system ticks, as does Arm internals.
    // Although we don't use the SDK we'll assume 1uS everywhere as well.
    ticks.proc0.control.enabled = false; // disable while configuring
    ticks.proc0.cycles.count    = 12;
    ticks.proc0.control.enabled = true;
    ticks.proc1.control.enabled = false; // disable while configuring
    ticks.proc1.cycles.count    = 12;
    ticks.proc1.control.enabled = true;

    m33.rvr()         = 1000;
    m33.csr().enable  = 1;
    m33.csr().tickInt = 1;
}

} // namespace rp2350::sys

using namespace rp2350;

constexpr static unsigned kHSTXDREQ    = 52; // p.1102
constexpr static unsigned kDMAChannelA = 0;
constexpr static unsigned kDMAChannelB = 1;
constexpr static unsigned kIRQDMA0     = DMA::kDMAIRQs[0];

void txNextLine() {
    using rp2350::DMA;

    ++currentLine;
    if (currentLine == kVTotal) {
        currentLine = 0;
        ++currentFrame;
    }

    // prepLine();

    auto dmaX      = (currentFrame & 1) ? kDMAChannelB : kDMAChannelA;
    auto& dma      = rp2350::dma.channels[dmaX];
    dma.readAddr   = uintptr_t(&lineBuffer(currentLine));
    dma.transCount = {.count = kHTotal, .mode = DMA::Mode::NORMAL};

    rp2350::dma.irqs[0].status = (1u << dmaX);
}

[[gnu::always_inline]]
void stuffU32(auto t) {
    while (hstx.fifo().stat.full) { sys::Insns().nop(); }
    *((uint32_t volatile*)&hstx.fifo().fifoWrite) = uint32_t(t);
}

// The actual application startup code, called by reset handler
[[gnu::used]] [[gnu::retain]] [[gnu::noreturn]] [[gnu::noinline]] void _start() {
    sys::initInterrupts();
    sys::initCPUBasic();
    sys::initSystemClock();
    sys::initSystemTicks();
    sys::initRefClock();
    sys::initPeriphClock();

    resets.unreset(Resets::Bit::PADSBANK0, true);
    resets.unreset(Resets::Bit::IOBANK0, true);

    initOutput<25>(); // config LED

    resets.unreset(Resets::Bit::DMA, true);

    resets.reset(Resets::Bit::HSTX);
    sys::initHSTXClock();

    initOutput<12>(GPIO::FuncSel<12>::HSTX);
    initOutput<13>(GPIO::FuncSel<13>::HSTX);
    initOutput<14>(GPIO::FuncSel<14>::HSTX);
    initOutput<15>(GPIO::FuncSel<15>::HSTX);
    initOutput<16>(GPIO::FuncSel<16>::HSTX);
    initOutput<17>(GPIO::FuncSel<17>::HSTX);
    initOutput<18>(GPIO::FuncSel<18>::HSTX);
    initOutput<19>(GPIO::FuncSel<19>::HSTX);
    sio.gpioOutClr = 0x000ff000;
    for (unsigned i = 0; i < 10000000; i++) { sys::Insns().nop(); }
    resets.unreset(Resets::Bit::HSTX, true);

    initOutput<12>(GPIO::FuncSel<12>::HSTX);
    initOutput<13>(GPIO::FuncSel<13>::HSTX);
    initOutput<14>(GPIO::FuncSel<14>::HSTX);
    initOutput<15>(GPIO::FuncSel<15>::HSTX);
    initOutput<16>(GPIO::FuncSel<16>::HSTX);
    initOutput<17>(GPIO::FuncSel<17>::HSTX);
    initOutput<18>(GPIO::FuncSel<18>::HSTX);
    initOutput<19>(GPIO::FuncSel<19>::HSTX);

    // See: p.1206: "As a final, concrete example, take TMDS (used in DVI): ..."
    // and: p.1207: "For double-data-rate data, with active rising and active falling
    // ..." (But note that the example project uses clkdiv of 5)
    // https://github.com/raspberrypi/pico-examples/blob/master/hstx/dvi_out_hstx_encoder/dvi_out_hstx_encoder.c
    //
    // This will use the same pinout:
    // Pico2 pin:   16    17    18    19    20    21    22    23    24    25
    // HSTX bit:     0     1   (gnd)   2     3     4     5   (gnd)   6     7
    // GPIO:        12    13   (gnd)  14    15    16    17   (gnd)  18    19
    // DVI signal:   + CHO -           + CLK -     + CH2 -           + CH1 -

    hstx.bits[0] = {.selectP = 0, .selectN = 1, .invert = 0};
    hstx.bits[1] = {.selectP = 0, .selectN = 1, .invert = 1};
    hstx.bits[2] = {.invert = 0, .clock = true};
    hstx.bits[3] = {.invert = 1, .clock = true};
    hstx.bits[4] = {.selectP = 20, .selectN = 21, .invert = 0};
    hstx.bits[5] = {.selectP = 20, .selectN = 21, .invert = 1};
    hstx.bits[6] = {.selectP = 10, .selectN = 11, .invert = 0};
    hstx.bits[7] = {.selectP = 10, .selectN = 11, .invert = 1};

    // Configure the HSTX expander for RGB565.
    // The datasheet and even the DVI example don't make this very clear.
    // We'll look at the setup for RGB332 and (with a little detective work) set up for
    // RGB565.
    //
    // Configure HSTX's TMDS encoder for RGB332
    // hstx_ctrl_hw->expand_tmds =
    //     2 << HSTX_CTRL_EXPAND_TMDS_L2_NBITS_LSB | 0 <<
    //     HSTX_CTRL_EXPAND_TMDS_L2_ROT_LSB | 2 << HSTX_CTRL_EXPAND_TMDS_L1_NBITS_LSB |
    //     29 << HSTX_CTRL_EXPAND_TMDS_L1_ROT_LSB | 1 <<
    //     HSTX_CTRL_EXPAND_TMDS_L0_NBITS_LSB | 26 << HSTX_CTRL_EXPAND_TMDS_L0_ROT_LSB;
    //
    // Pixels (TMDS) come in 4 8-bit chunks. Control symbols (RAW) are an entire 32-bit
    // word. hstx_ctrl_hw->expand_shift = 0
    //     | 4 << HSTX_CTRL_EXPAND_SHIFT_ENC_N_SHIFTS_LSB
    //     | 8 << HSTX_CTRL_EXPAND_SHIFT_ENC_SHIFT_LSB
    //     | 1 << HSTX_CTRL_EXPAND_SHIFT_RAW_N_SHIFTS_LSB
    //     | 0 << HSTX_CTRL_EXPAND_SHIFT_RAW_SHIFT_LSB;
    //
    // In the DVI example, four 8-bit pixels are packed into a 32-bit word.
    //
    // 31....25 24....17 16.....8 7......0
    // [Pixel3] [Pixel2] [Pixel1] [Pixel0]
    //
    // ENC_N_SHIFTS is 4 to corresponding to the four pixels, and ENC_SHIFT is 8.
    // The RGB components in each pixel is arranged like:
    //
    //   76543210
    //   RRRGGGBB
    //
    // R, G, and B have bit widths of 3, 3, and 2; the Lk_NBITS for lanes 2, 1, and 0
    // are those bit widths minus 1, so they're 2, 2, and 1.
    //
    // The rotation fields are 0(R), 29(G), and 26(B).
    // So R (L0) stays where it is, and gets zero-extended:    RRR-----
    // G (L1) rotates right 29 (equivalently, 3 to the left):  GGG-----
    // and B (L2) rotates right by 26 (i.e. left-rotate 6):    BB------
    //
    // Let's now find the rotates and shifts and all that for RGB565.
    // A packed 32-bit word then has 2 pixels:
    //
    //  3         2         1
    // 10987654321098765432109876543210
    // RRRRRGGGGGGBBBBBRRRRRGGGGGGBBBBB
    //
    // Each 16-bit pixel looks like:
    // 1    1
    // 5432109876543210
    // RRRRRGGGGGGBBBBB; so to get R, G, and B into position (still 8-bit color values):
    //         RRRRR---
    //         GGGGGG--
    //         BBBBB---
    //
    // we'll need L2/1/0 bit-width values (remember they're one less) of 4, 5, and 4,
    // and right-rotation values of 8, 3, and (32 - 3).

    hstx.expandShift = {
        .rawShift = 0, .rawNShifts = 1, .encShift = 16, .encNShifts = 2};

    hstx.expandTMDS = {
        .l0Rot = 29, .l0NBits = 4, .l1Rot = 3, .l1NBits = 5, .l2Rot = 8, .l2NBits = 4};

    hstx.csr = {
        .enable = true, .expandEnable = true, .shift = 2, .nShifts = 5, .clkDiv = 5};

    currentFrame = currentLine = 0;

    auto const s00 = (kControl[0] << 20) | (kControl[0] << 10) | (kControl[0] << 0);
    auto const s01 = (kControl[0] << 20) | (kControl[0] << 10) | (kControl[1] << 0);
    auto const s10 = (kControl[0] << 20) | (kControl[0] << 10) | (kControl[2] << 0);
    auto const s11 = (kControl[0] << 20) | (kControl[0] << 10) | (kControl[3] << 0);
    auto const vp  = videoPreamble();
    auto const vg  = videoGuard();

    while (true) {
        if (currentLine < 10) {
            stuffU32(16u | (1u << 12));
            stuffU32(s00);
            stuffU32(96u | (1u << 12));
            stuffU32(s01);
            stuffU32((48u + 640u) | (1u << 12));
            stuffU32(s00);
        } else if (currentLine < 12) {
            stuffU32(16u | (1u << 12));
            stuffU32(s10);
            stuffU32(96u | (1u << 12));
            stuffU32(s11);
            stuffU32((48u + 640u) | (1u << 12));
            stuffU32(s10);
        } else if (currentLine < 45) {
            stuffU32(16u | (1u << 12));

            stuffU32(s00);
            stuffU32(96u | (1u << 12));
            stuffU32(s01);
            stuffU32((48u + 640u) | (1u << 12));
            stuffU32(s00);
        } else {
            stuffU32(16u | (1u << 12));
            stuffU32(s00);
            stuffU32(96u | (1u << 12));
            stuffU32(s01);
            stuffU32(38u | (1u << 12));
            stuffU32(s00);
            stuffU32(8u | (1u << 12));
            stuffU32(vp);
            stuffU32(2u | (1u << 12));
            stuffU32(vg);
            stuffU32(160u | (3u << 12));
            stuffU32(0b11111'000000'00000'11111'000000'00000);
            stuffU32(160u | (3u << 12));
            stuffU32(0b00000'111111'00000'00000'111111'00000);
            stuffU32(160u | (3u << 12));
            stuffU32(0b00000'000000'11111'00000'000000'11111);
            stuffU32(160u | (3u << 12));
            stuffU32(0b11111'111111'00000'11111'111111'00000);
        }

        ++currentLine;
        if (currentLine == kVTotal) {
            currentLine = 0;
            ++currentFrame;
        }

        auto f = currentFrame % 60;
        if (f < 30) {
            sio.gpioOutSet = 1 << 25;
        } else {
            sio.gpioOutClr = 1 << 25;
        }
    }
    // ///////////////////////////////////////////////
    // ///////////////////////////////////////////////
    // ///////////////////////////////////////////////
    // ///////////////////////////////////////////////
    // ///////////////////////////////////////////////
    // ///////////////////////////////////////////////
    // ///////////////////////////////////////////////
    // ///////////////////////////////////////////////
    // ///////////////////////////////////////////////
    // ///////////////////////////////////////////////
    // ///////////////////////////////////////////////
    // ///////////////////////////////////////////////
    // ///////////////////////////////////////////////
    // ///////////////////////////////////////////////
    // ///////////////////////////////////////////////
    // ///////////////////////////////////////////////
    // ///////////////////////////////////////////////
    // ///////////////////////////////////////////////
    // ///////////////////////////////////////////////
    // ///////////////////////////////////////////////
    // ///////////////////////////////////////////////

    sys::irqHandlers[kIRQDMA0] = txNextLine;

    auto& chA = dma.channels[kDMAChannelA];
    update(&chA.ctrl, [](Update<decltype(chA.ctrl)>& _) {
        _.zero();
        _->chainTo  = kDMAChannelB;
        _->incrRead = true;
        _->treqSel  = kHSTXDREQ;
        _->dataSize = DMA::DataSize::_32BIT;
        _->enable   = true;
    });
    auto& chB = dma.channels[kDMAChannelB];
    update(&chB.ctrl, [](Update<decltype(chB.ctrl)>& _) {
        _.zero();
        _->chainTo  = kDMAChannelA;
        _->incrRead = true;
        _->treqSel  = kHSTXDREQ;
        _->dataSize = DMA::DataSize::_32BIT;
        _->enable   = true;
    });

    auto& dmaA      = rp2350::dma.channels[kDMAChannelA];
    dmaA.writeAddr  = uintptr_t(&hstx.fifo().fifoWrite);
    dmaA.readAddr   = uintptr_t(&bufA);
    dmaA.transCount = {.count = kHTotal, .mode = DMA::Mode::NORMAL};
    auto& dmaB      = rp2350::dma.channels[kDMAChannelB];
    dmaA.writeAddr  = uintptr_t(&hstx.fifo().fifoWrite);
    dmaA.readAddr   = uintptr_t(&bufB);
    dmaA.transCount = {.count = kHTotal, .mode = DMA::Mode::NORMAL};

    rp2350::dma.irqs[0].rawStatus = (1u << kDMAChannelA) | (1u << kDMAChannelB);
    rp2350::dma.irqs[0].enable    = (1u << kDMAChannelA) | (1u << kDMAChannelB);
    m33.enableIRQ(kIRQDMA0);

    bufA.init();
    bufB.init();
    currentFrame = 0;
    currentLine  = 0;

    rp2350::dma.multiChanTrigger.channels = (1u << kDMAChannelA);

    while (true) {
        sys::Insns().nop();
        auto f = currentFrame % 60;
        if (f < 30) {
            sio.gpioOutSet = 1 << 25;
        } else {
            sio.gpioOutClr = 1 << 25;
        }
    }
}
