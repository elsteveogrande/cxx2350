/*

HDMI with HSTX video (and eventually audio) generator.
Generates 848x480 @60p on a Pico2 at 150MHz (effective 300MHz DDR).
That has a familiar vertical resolution with an appropriately-scaled
horizontal resolution (i.e. nearest multiple of 8 to a true 1.777).
Actual ASR is 1.766, which is -0.6% off target (if ratio-ratios makes sense).

https://tomverbeure.github.io/video_timings_calculator?horiz_pixels=848&vert_pixels=480
gives us the following data.  Thank you Tom for this excellent calculator!

I plugged in the resolution, along with exact 60 Hz frame rate.
I added HBlank and VBlank times to make the total width and height (in pixel-times)
exactly 1000x500, totaling 300Mbit/sec bandwidth.  I chose front/back porch and sync
durations roughly in line with CVT and CEA standards.

Walking through the HSTX section of the datasheet:

Section 12.11.3.2 has an example (conveniently) for DVI (HDMI uses the same protocol).
We'll have the FIFO consuming 32-bit words, each with three 10-bit fields.

We communicate this mapping to the CSR and BITn registers.
This sets up for 5 periods, shifting right by 2 after each.
Each period is DDR, so a bit is transferred on the up and down parts of the clock,
so we get 10 bits total.

CSR:   NSHIFTS=5, SHIFT=2
BIT0:  selP=0, selN=1, inv=0
BIT1:  selP=0, selN=1, inv=1
BIT2:  selP=10, selN=11, inv=0
BIT3:  selP=10, selN=11, inv=1
BIT4:  selP=20, selN=21, inv=0
BIT5:  selP=20, selN=21, inv=1

p.1206 explains the clock signal which we'll set up as:
BIT6:  clk=1, inv=0
BIT7:  clk=1, inv=1

Section 12.11.4.1 shows how to create a center-aligned clock, which we also will use.
p.1207, "For double-data-rate data, with active rising and active falling edges":
CSR.CLKDIV=2, CSR.CLKPHASE=1

Example HSTX app for DVI:
https://github.com/raspberrypi/pico-examples/blob/master/hstx/dvi_out_hstx_encoder/dvi_out_hstx_encoder.c

*/

#include <cxx20/cxxabi.h>
#include <rp2350/clocks.h>
#include <rp2350/common.h>
#include <rp2350/gpio.h>
#include <rp2350/insns.h>
#include <rp2350/interrupts.h>
#include <rp2350/m33.h>
#include <rp2350/pads.h>
#include <rp2350/panic.h>
#include <rp2350/resets.h>
#include <rp2350/ticks.h>
#include <rp2350/uart.h>
#include <rp2350/xoscpll.h>

namespace rp2350::sys {

// Need to define a couple of structures in our main file so that they are baked into the ELF.
// These two are given `section` attributes so that they can be placed at specific flash
// addresses (see `layout.ld`).

// Interrupt vectors are needed for the thing to start; this will live at flash address
// `0x10000000`. It can live in a different address but the default is fine.
[[gnu::used]] [[gnu::retain]] [[gnu::section(".vec_table")]] ARMVectors const gARMVectors;

// Image definition is required for the RP2 bootloader; this will live at flash address
// `0x10000100`.
[[gnu::used]] [[gnu::retain]] [[gnu::section(
    ".image_def")]] constinit ImageDef2350ARM const gImageDef;

} // namespace rp2350::sys

struct [[gnu::packed]] TMDS {
    unsigned ch0 : 10 {};
    unsigned ch1 : 10 {};
    unsigned ch2 : 10 {};
    unsigned     : 2;

    operator uint32_t() const { return *(uint32_t*)(this); }
};
static_assert(sizeof(TMDS) == 4);

struct TERC {
    unsigned code : 10;
    constexpr operator unsigned() const { return unsigned(code); };
    constexpr TERC operator~() const { return {.code = unsigned(code ^ 0b1111111111)}; }
};

// For encoding 4 data bits
constexpr static TERC kTERC[16] {
    {.code = 0b1010011100}, {.code = 0b1001100011}, {.code = 0b1011100100}, {.code = 0b1011100010},
    {.code = 0b0101110001}, {.code = 0b0100011110}, {.code = 0b0110001110}, {.code = 0b0100111100},
    {.code = 0b1011001100}, {.code = 0b0100111001}, {.code = 0b0110011100}, {.code = 0b1011000110},
    {.code = 0b1010001110}, {.code = 0b1001110001}, {.code = 0b0101100011}, {.code = 0b1011000011},
};

// For encoding 2 control bits:
// CH0: D0=HSYNC  D1=VSYNC
// CH1: D0=CTL0   D1=CTL1
// CH2: D0=CTL2   D1=CTL3
constexpr static TERC kControl[4] {
    {.code = 0b1101010100},
    {.code = 0b0010101011},
    {.code = 0b0101010100},
    {.code = 0b1010101011},
};

// Codes for the 32 levels of RGB color channels.
// TODO: use HSTX's expander or the standalone TMDS converter.
// For now use a fixed table with reasonable patterns (almost-balanced ones and zeros).
// Generated by `misc/tablegen.py`.
constexpr static TERC kColors[32] {
    {.code = 0b0111110000}, /*  16 (5 ones) */
    {.code = 0b0111110010}, /*  23 (6 ones) */
    {.code = 0b0111100000}, /*  30 (4 ones) */
    {.code = 0b0111100010}, /*  37 (5 ones) */
    {.code = 0b0111100100}, /*  44 (5 ones) */
    {.code = 0b0111101100}, /*  51 (6 ones) */
    {.code = 0b0111101000}, /*  58 (5 ones) */
    {.code = 0b0100111110}, /*  65 (6 ones) */
    {.code = 0b0111000110}, /*  72 (5 ones) */
    {.code = 0b0100111010}, /*  79 (5 ones) */
    {.code = 0b0100110011}, /*  86 (5 ones) */
    {.code = 0b0111001010}, /*  93 (5 ones) */
    {.code = 0b0111011100}, /* 100 (6 ones) */
    {.code = 0b0111011010}, /* 107 (6 ones) */
    {.code = 0b0111010001}, /* 114 (5 ones) */
    {.code = 0b0111010100}, /* 121 (5 ones) */
    {.code = 0b0111010101}, /* 129 (6 ones) */
    {.code = 0b0101111000}, /* 136 (5 ones) */
    {.code = 0b0101110000}, /* 143 (4 ones) */
    {.code = 0b0101110010}, /* 150 (5 ones) */
    {.code = 0b0110001011}, /* 157 (5 ones) */
    {.code = 0b0110011100}, /* 164 (5 ones) */
    {.code = 0b0110011001}, /* 171 (5 ones) */
    {.code = 0b0101101100}, /* 178 (5 ones) */
    {.code = 0b0110010110}, /* 185 (5 ones) */
    {.code = 0b0110010101}, /* 192 (5 ones) */
    {.code = 0b0110111000}, /* 199 (5 ones) */
    {.code = 0b0110110000}, /* 206 (4 ones) */
    {.code = 0b0110110010}, /* 213 (5 ones) */
    {.code = 0b0101001011}, /* 220 (5 ones) */
    {.code = 0b0101011100}, /* 227 (5 ones) */
    {.code = 0b0101011001}, /* 234 (5 ones) */
};

TMDS color(uint8_t r, uint8_t g, uint8_t b) {
    return {.ch0 = kColors[r], .ch1 = kColors[g], .ch2 = kColors[b]};
}

// Encode 6 bits (2 bits across 3 channels)
constexpr TMDS control(uint8_t ch2, uint8_t ch1, uint8_t ch0) {
    return {
        .ch0 = kControl[ch0 & 0x03].code,
        .ch1 = kControl[ch1 & 0x03].code,
        .ch2 = kControl[ch2 & 0x03].code,
    };
}

// Encode 6 bits (2 bits across 3 channels): CTL3..0, plus set CH0 ctl bits for sync
constexpr TMDS control(uint8_t ch2, uint8_t ch1, bool vsync, bool hsync) {
    uint8_t v = vsync ? 0b10 : 0b00;
    uint8_t h = hsync ? 0b01 : 0b00;
    return control(ch2, ch1, v | h);
}

constexpr TMDS idle() { return control(0x00, 0x00, 0x00); }
constexpr TMDS sync(bool vsync, bool hsync) { return control(0x00, 0x00, vsync, hsync); }
constexpr TMDS hsync() { return control(0x00, 0x00, false, true); }

constexpr TMDS dataPreamble(bool hsync = false, bool vsync = false) {
    // Table 5-2; watch out for the CTL bit order.  CTL3:0 = 0101
    return control(0b01, 0b01, vsync, hsync);
}

constexpr TMDS videoPreamble(bool hsync = false, bool vsync = false) {
    // Table 5-2; watch out for the CTL bit order.  CTL3:0 = 0001
    return control(0b00, 0b01, vsync, hsync);
}

constexpr TMDS dataGuard(bool hsync = false, bool vsync = false) {
    auto v = vsync ? 0b0010 : 0;
    auto h = hsync ? 0b0001 : 0;
    return {.ch0 = kTERC[0b1100 | v | h].code, .ch1 = ~kTERC[8], .ch2 = ~kTERC[8]};
}

constexpr TMDS videoGuard() { return {.ch0 = kTERC[8], .ch1 = ~kTERC[8], .ch2 = kTERC[8]}; }

// Write the above sequence into buf (should be length 152)
constexpr void genVideoHBlank(TMDS* buf) {
    unsigned i = 0;
    // We'll start the line in a control period
    while (i < 24) { buf[i++] = idle(); }
    while (i < 46) { buf[i++] = hsync(); }
    while (i < 54) { buf[i++] = dataPreamble(true); } // start preamble (hsync continues)
    while (i < 56) { buf[i++] = dataGuard(true); }    // data guard band (hsync continues)
    // Data period starts after the data guard band.
    while (i < 88) { buf[i++] = sync(false, false); }  // nop, placeholder for audio sample
    while (i < 120) { buf[i++] = sync(false, false); } // nop, placeholder for audio sample
    while (i < 122) { buf[i++] = dataGuard(); }        // data guard also ends data period
    // Back to a control period
    while (i < 142) { buf[i++] = idle(); }
    while (i < 154) { buf[i++] = videoPreamble(); }
    while (i < 156) { buf[i++] = videoGuard(); }
    // End of the hblank line "header"; after this we send pixels from `buf.pixels`
}

struct TMDSBuffer {
    TMDS hblank[152];
    TMDS pixels[848];
};
static_assert(sizeof(TMDSBuffer) <= 4096);

// We'll claim SRAM8 and SRAM9 for two separately-bussed buffers (see Section 2.2.3 "SRAM").
// We purposely avoid accessing (for read or write) the region of memory currently being
// used by DMA so as to avoid stalls or jitter.
auto& bufA = *(TMDSBuffer*)(0x20080000); // Even lines
auto& bufB = *(TMDSBuffer*)(0x20081000); // Odd lines

// Output line: the line currently being displayed.
// Lines 0-19 are vblank; 20-499 are for active video and data islands.
unsigned currentLine  = 0;
unsigned currentFrame = 0;

// Return a reference to a TMDS buffer (one of `bufA` or `bufB`) depending on line number
constexpr auto& lineBuffer(unsigned oline) { return (oline & 1) ? bufB : bufA; }

// Generate an empty (no-pixel, no-data) line for the vsync period.
// Line will contain hsync pulse (and vsync throughout, if requested).
void prepVBlankLine(TMDSBuffer& buf, bool vsync) {
    unsigned i = 0;
    while (i < 24) { buf.hblank[i++] = sync(vsync, false); }
    while (i < 46) { buf.hblank[i++] = sync(vsync, true); } // hsync
    while (i < 152) { buf.hblank[i++] = sync(vsync, false); }
    i = 0;
    while (i < 848) { buf.pixels[i++] = sync(vsync, false); }
}

// Write pixels into `buf.pixels`.  `displayLine` is in range 0 to 479.
void prepVideoLine(TMDSBuffer& buf, unsigned displayLine) {
    genVideoHBlank(buf.hblank);
    (void)displayLine;
    for (unsigned x = 0; x < 848; x++) { buf.pixels[x] = color(30, 10, 20); }
}

void prepLine() {
    // Some of this can be prepped and reused (like the vblank lines)
    // but I want this to go through the exercise of generating data
    // for every single pixel, every single line, to test timing.
    auto& buf = lineBuffer(currentLine);
    if (currentLine < 6) {
        prepVBlankLine(buf, false);
    } else if (currentLine < 14) {
        prepVBlankLine(buf, true);
    } else if (currentLine < 20) {
        prepVBlankLine(buf, false);
    } else {
        prepVideoLine(buf, currentLine - 20);
    }
}

namespace rp2350::sys {

void initCPUBasic() {
    m33.ccr().unalignedTrap = true;
    m33.ccr().div0Trap      = true;
}

void initSystemClock() {
    xosc.init();
    sysPLL.init();

    clocks.sys.control = {.source    = Clocks::Sys::Source::CLK_SYS_AUX,
                          .auxSource = Clocks::Sys::AuxSource::PLL_SYS};
    clocks.sys.div     = {.fraction = 0, .integer = 1};
}

void initRefClock() {
    clocks.ref.control = {.source = Clocks::Ref::Source::XOSC, .auxSource = {}};
    clocks.ref.div     = {.fraction = 0, .integer = 1};
}

void initPeriphClock() {
    clocks.peri.control = {
        .auxSource = Clocks::Peri::AuxSource::PLL_SYS, .kill = false, .enable = true};
    clocks.peri.div = {.fraction = 0, .integer = 1};
}

void initHSTXClock() {
    update(&clocks.hstx.control, [](auto& _) {
        _.zero();
        _->auxSource = Clocks::HSTX::AuxSource::CLK_SYS;
        _->kill      = false;
        _->enable    = true;
    });
    clocks.hstx.div = {.fraction = 0, .integer = 1};
}

void initSystemTicks() {
    // p569: SDK expects nominal 1uS system ticks, as does Arm internals.
    // Although we don't use the SDK we'll assume 1uS everywhere as well.
    ticks.proc0.control.enabled = false; // disable while configuring
    ticks.proc0.cycles.count    = 12;
    ticks.proc0.control.enabled = true;
    ticks.proc1.control.enabled = false; // disable while configuring
    ticks.proc1.cycles.count    = 12;
    ticks.proc1.control.enabled = true;

    m33.rvr()         = 1000;
    m33.csr().enable  = 1;
    m33.csr().tickInt = 1;
}

} // namespace rp2350::sys

using namespace rp2350;

constexpr static unsigned kHSTXDREQ   = 52; // p.1102
constexpr static unsigned kDMAChannel = 0;
constexpr static unsigned kDMADREQIRQ = 0;
constexpr static unsigned kDMAIRQ     = DMA::kDMAIRQs[kDMADREQIRQ];

void txNextLine() {
    using rp2350::DMA;

    auto& dma          = rp2350::dma.channels[0];
    dma.writeAddr      = uintptr_t(&lineBuffer(currentLine));
    dma.transCountTrig = {.count = 1000, .mode = DMA::Mode::NORMAL};

    if (++currentLine == 500) {
        currentLine = 0;
        ++currentFrame;
    }
    prepLine();

    rp2350::dma.irqs[kDMADREQIRQ >> 4].status = (1u << 0); // clear interrupt flag
}

template <unsigned K> void stuff(TMDS t) {
    while (hstx.fifo().stat.level >= 8 - K) { sys::Insns().nop(); }
    for (unsigned i = 0; i < K; i++) { *((uint32_t volatile*)&hstx.fifo().fifoWrite) = t; }
}

void stuffIntoFIFO() {

    auto vb_nosync = sync(false, false);
    auto vb_hsync  = sync(false, true);
    auto vb_vsync  = sync(true, false);
    auto vb_hvsync = sync(true, true);
    auto vp        = videoPreamble();
    auto vg        = videoPreamble();
    auto c         = color(30, 10, 20);

    while (true) {
        unsigned x = 0;

        // while (x++ < 6) { stuff<4>(vb_nosync); }
        // while (x++ < 14) { stuff<4>(vb_hsync); }
        // while (x++ < 250) { stuff<4>(vb_nosync); }

        if (currentLine < 6) {
            while (x++ < 6) { stuff<4>(vb_nosync); }
            while (x++ < 14) { stuff<4>(vb_hsync); }
            while (x++ < 250) { stuff<4>(vb_nosync); }
        } else if (currentLine < 14) {
            while (x++ < 6) { stuff<4>(vb_vsync); }
            while (x++ < 14) { stuff<4>(vb_hvsync); }
            while (x++ < 250) { stuff<4>(vb_vsync); }
        } else if (currentLine < 20) {
            while (x++ < 6) { stuff<4>(vb_nosync); }
            while (x++ < 14) { stuff<4>(vb_hsync); }
            while (x++ < 250) { stuff<4>(vb_nosync); }
        } else if (currentLine < 500) {
            while (x++ < 12) { stuff<2>(vb_nosync); }
            while (x++ < 28) { stuff<2>(vb_hsync); }
            while (x++ < 71) { stuff<2>(vb_nosync); }
            while (x++ < 75) { stuff<2>(vp); }
            while (x++ < 76) { stuff<2>(vg); }
            x = 0;
            while (x++ < 212) { stuff<4>(c); }

            //     // while (x++ < 24) { stuff(vb_nosync); }
            //     // while (x++ < 56) { stuff(vb_hsync); }
            //     // while (x++ < 142) { stuff(vb_nosync); }
            //     // while (x++ < 150) { stuff(vp); }
            //     // while (x++ < 152) { stuff(vg); }
            //     // while (x++ < 1000) { stuff(c); }
        }

        ++currentLine;
        if (currentLine == 500) {
            currentLine = 0;
            ++currentFrame;
        }

        if (currentFrame % 60 < 30) {
            sio.gpioOutSet = 1 << 25;
        } else {
            sio.gpioOutClr = 1 << 25;
        }
    }
}

// The actual application startup code, called by reset handler
[[gnu::used]] [[gnu::retain]] [[gnu::noreturn]] [[gnu::noinline]] void _start() {
    sys::initInterrupts();
    sys::initCPUBasic();
    sys::initSystemClock();
    sys::initSystemTicks();
    sys::initRefClock();
    sys::initPeriphClock();

    resets.unreset(Resets::Bit::PADSBANK0, true);
    resets.unreset(Resets::Bit::IOBANK0, true);

    initGPIOOutput<25>(); // config LED

    // some DMA sample code on p.1108
    // See also sdk example:
    // https://github.com/raspberrypi/pico-examples/blob/master/hstx/dvi_out_hstx_encoder/dvi_out_hstx_encoder.c
    // Default DMA config:
    // https://www.raspberrypi.com/documentation/pico-sdk/hardware.html#group_channel_config_1ga7a9107effdfa5f18b9577b4925589b4b

    sys::initHSTXClock();
    resets.unreset(Resets::Bit::HSTX, true);

    initGPIOOutput<12>(GPIO::FuncSel<12>::HSTX);
    initGPIOOutput<13>(GPIO::FuncSel<13>::HSTX);
    initGPIOOutput<14>(GPIO::FuncSel<14>::HSTX);
    initGPIOOutput<15>(GPIO::FuncSel<15>::HSTX);
    initGPIOOutput<16>(GPIO::FuncSel<16>::HSTX);
    initGPIOOutput<17>(GPIO::FuncSel<17>::HSTX);
    initGPIOOutput<18>(GPIO::FuncSel<18>::HSTX);
    initGPIOOutput<19>(GPIO::FuncSel<19>::HSTX);

    // See: p.1206: "As a final, concrete example, take TMDS (used in DVI): ..."
    // and: p.1207: "For double-data-rate data, with active rising and active falling edges,
    // ..." The example project uses clkdiv of 5:
    // https://github.com/raspberrypi/pico-examples/blob/master/hstx/dvi_out_hstx_encoder/dvi_out_hstx_encoder.c
    hstx.bits[0] = {.selectP = 0, .selectN = 1, .invert = 0};
    hstx.bits[1] = {.selectP = 0, .selectN = 1, .invert = 1};
    hstx.bits[2] = {.selectP = 10, .selectN = 11, .invert = 0};
    hstx.bits[3] = {.selectP = 10, .selectN = 11, .invert = 1};
    hstx.bits[4] = {.selectP = 20, .selectN = 21, .invert = 0};
    hstx.bits[5] = {.selectP = 20, .selectN = 21, .invert = 1};
    hstx.bits[6] = {.invert = 0, .clock = true};
    hstx.bits[7] = {.invert = 1, .clock = true};
    hstx.csr     = {.enable = true, .shift = 2, .nShifts = 5, .clkDiv = 5};

    currentFrame = 0;
    currentLine  = 0;
    prepLine();

    stuffIntoFIFO(); ///////////////////////////////////////////////////////////////

    resets.unreset(Resets::Bit::DMA, true);

    sys::irqHandlers[kDMAIRQ] = txNextLine;

    dma.irqs[kDMADREQIRQ >> 4].enable = (1u << 0);
    m33.enableIRQ(kDMAIRQ);

    auto& ch = dma.channels[0];
    update(&ch.ctrl, [](Update<decltype(ch.ctrl)>& _) {
        _.zero();
        _->incrRead = true;
        _->treqSel  = kHSTXDREQ;
        _->chainTo  = kDMAChannel; // itself
        _->dataSize = DMA::DataSize::_32BIT;
        _->enable   = true;
    });

    // Subsequent DMA transfers are triggered by `txNextLine` itself.
    m33.triggerIRQ(kDMAIRQ);

    while (true) {
        sys::Insns().wfi();
        if (currentFrame % 60 < 30) {
            sio.gpioOutSet = 1 << 25;
        } else {
            sio.gpioOutClr = 1 << 25;
        }
    }
}
